         1866104 function calls (1865904 primitive calls) in 4.015 seconds

   Ordered by: cumulative time
   List reduced from 325 to 10 due to restriction <10>

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    1.322    1.322    4.015    4.015 thining_algorithm.py:28(thining)
   146258    1.224    0.000    1.557    0.000 thining_algorithm.py:119(is8Simple)
        5    0.000    0.000    0.746    0.149 thining_algorithm.py:14(colorPixelLocations)
        1    0.637    0.637    0.637    0.637 thining_algorithm.py:17(<listcomp>)
866569/866538    0.194    0.000    0.194    0.000 {built-in method builtins.len}
   600130    0.147    0.000    0.147    0.000 {method 'append' of 'list' objects}
        1    0.000    0.000    0.132    0.132 Image.py:862(convert)
        1    0.001    0.001    0.112    0.112 ImageFile.py:154(load)
        4    0.109    0.027    0.109    0.027 thining_algorithm.py:23(<listcomp>)
        6    0.103    0.017    0.103    0.017 {method 'decode' of 'ImagingDecoder' objects}





Code=======================================================================



from PIL import Image, ImageOps
import numpy as np


import cProfile
import pstats
# on, off = 0,1
on, off = 1,0
# on, off = 0, 255

# Returns a list of all pixels with coordinates of given "color", the pixels are collected through listOfPixels and/or bound
# listOfPixels Contains a list of pixel-coordinates that are checked
# bound is a bounding box of the image, only pixels inside the box was changed last iteration
def colorPixelLocations(px, color=on, listOfPixels=None, bound=None):
    if listOfPixels is None and bound is not None:
        # When content in bound is unknown
        return [(col, row) for col in range(bound[0][0], bound[1][0]) for row in range(bound[0][1], bound[1][1]) if px[(col, row)] == color]
    elif listOfPixels is not None and bound is None:
        # When black pixels of last pass, across image is known
        return [pixel for pixel in listOfPixels if px[pixel] == color]
    elif listOfPixels is not None and bound is not None:
        # When black pixels of last pass, across image is known and no changes were made outside bound
        return [pixel for pixel in listOfPixels if px[pixel] == color and bound[0][0] <= pixel[0] <= bound[1][0] and bound[0][1] <= pixel[1] <= bound[1][1]]
    else:
        raise AttributeError("listOfPixels and bound can't both be None")


def thining(filename):
    # on is color of graph and off is color of background
    # on, off = 0,1
    # Threshold for making image binary (as every pixel is between 0 and 255)
    threshold = 200
    # 1 is part of graph and 0 is background (on monitor, displayed as black background with a with graph and text)
    # Inverts image white-black
    def threshold_function(x):
        return off if x > threshold else on
    im = Image.open(filename).convert("L").point(threshold_function, mode='1')
    # Crop with bounding box crops largest possible black border around image
    im = im.crop(im.getbbox())
    # adds a 1 pixel wide border around image to prevent algorithm from trying to access pixels outside
    im = ImageOps.expand(im, border=1, fill=off)

    array = np.asarray(im)

    width, height = im.size

    #todo remove
    px = im.load()

    # todo remove
    # directions = ["N","S","W","E"]
    # coordinate (0,0) is top-left corner
    directions = [(0, -1), (0, 1), (-1, 0), (1, 0)]

    # bounding box of the image, only pixels inside the box was changed last iteration (at initiation it's 1 pixel inside the edge of the image)
    bounding_box_of_changes = ((1, 1), (width - 1, height - 1))

    # Returns list of pixels that are ON (on=1 and off=0) within bounding_box_of_changes
    ON_pixel_coordinates_within_bound = colorPixelLocations(
        px, color=on, bound=bounding_box_of_changes)

    pixel_deleted = True
    index = 0
    while pixel_deleted:
        index += 1
        ON_pixel_coordinates_within_bound = colorPixelLocations(
            px, color=on, listOfPixels=ON_pixel_coordinates_within_bound, bound=bounding_box_of_changes)
        # print("Pass: {}, Black pixels: {}, removed: {}".format(index, len(ON_pixel_coordinates_within_bound),svarta-len(ON_pixel_coordinates_within_bound)))
        # print(bounding_box_of_changes)

        crop_constraint = ((width - 1, height - 1), (1, 1))
        pixel_deleted = False
        for i, d in enumerate(directions):
            marked_pixels = []

            # For each pixel i_xy
            for (col, row) in ON_pixel_coordinates_within_bound:
                i_xy = (x, y) = (col, row)
                # todo change directions to d[0] and d[1]
                i_d = (col + directions[i][0], row + directions[i][1])

                # A) Pixel is white
                if px[i_xy] == off:
                    continue
                # B) Pixel is black, but not edge in direction
                if px[i_d] == on:
                    continue
                # C) Pixel is an endpoint
                # List of colors of neighbor pixels, start in top-left pixel, end in left pixel
                neighborColors = [px[(x - 1, y - 1)], px[(x, y - 1)], px[(x + 1, y - 1)], px[(
                    x + 1, y)], px[(x + 1, y + 1)], px[(x, y + 1)], px[(x - 1, y + 1)], px[(x - 1, y)]]
                if neighborColors.count(on) <= 1:
                    continue
                # D) Is not 8-Simple, removing pixel does affect connectivness of neighboring pixels, therefore don't remove pixel
                if not is8Simple(neighborColors):
                    continue

                # mark pixel i_xy for deletion
                marked_pixels.append(i_xy)

                crop_constraint = (
                    (min(crop_constraint[0][0], i_xy[0] - 1),
                     min(crop_constraint[0][1], i_xy[1] - 1)),
                    (max(crop_constraint[1][0], i_xy[0] + 1),
                     max(crop_constraint[1][1], i_xy[1] + 1))
                )

                pixel_deleted = True
            # print("Marked pixels: {}".format(len(marked_pixels)))
            for i_xy in marked_pixels:
                px[i_xy] = off
        bounding_box_of_changes = crop_constraint

    # print("bounding_box_of_changes:",bounding_box_of_changes)
    # print("Passes: ", index)
    return im


def is8Simple(neighborColors):
    eight_simple = []
    for j, e in enumerate(neighborColors):
        if not (j % 2 == 0 and e == off) and (len(eight_simple) == 0 or e != eight_simple[-1]):
            # If NOT (Corner AND white) AND (previous pixel different from current pixel)
            # Adds edge pixels and black corner pixels while preventing repetition of same color in list (edge connected to 4 while corner only 2 pixels)
            eight_simple.append(e)
    l = len(eight_simple)
    if l <= 2 or l == 3 and (eight_simple[0] == off or
                             eight_simple[0] == eight_simple[-1]):
        return True
    return False
    # if not (len(eight_simple) <= 2 or len(eight_simple) == 3 and (eight_simple[0] == off or eight_simple[0] == eight_simple[-1])
    #     or (len(eight_simple) == 4 and neighborColors[0] == off and neighborColors[-1] == neighborColors[1]==on)):


if __name__ == "__main__":
    pr = cProfile.Profile()

    filename = "graphs/lars_graph16.png"
    # threshold = 200
    # # Correct Color-scheme
    # # 1 is part of graph and 0 is background (on monitor, displayed as black background with a with graph)
    # def threshold_function(x): return off if x > threshold else on
    # # def threshold_function(x): return 255 if x > threshold else 0
    # im = Image.open(filename).convert("L").point(threshold_function, mode='1')
    # im = im.crop(im.getbbox())
    # print(im.getbbox())

    # im.show()
    pr.enable()

    im = thining(filename)

    pr.disable()
    stats = pstats.Stats(pr).strip_dirs().sort_stats('cumtime')
    stats.print_stats(10)
    # pr.print_stats(sort=2)
    im.show()
